синх. взаим.

http - знаем про заголовки,  тело ответа и пр.
rpc - удалённый вызов процедур. в коде выглядит как простой вызов метода(который вычислется на каком-нибудь микросервисе). мы можем не догадываться, какой транспорт используется. может использоваться и http. но для работы будет требоваться брокер сообщений.
grpc - фреймворк. rpc на http2. но можно и на брокере сообщений сделать. требуется подключать необходимые библиотееки.

основная проблема: клиент блокируется до окончания выполнения запроса

в руби есть ruby entrpreteur lock - отсутствует нативная возмостть выполнять несколько потоков параллельно.
т.е. даже если мы будем использовать треды в руби, то выйгрыша в производителоьности мы не получим, т.к. в каждый момент времени в одном руби процессе может выполняться только один тред.

если есть много задач с ожидание по IO (сетевые вызовы, и пр, т.е. мы запросили что-то от системы ввода-вывода и ожидаем), то в этотм случае руби переключиться между тредами. т.е. здесь, при использовании многих тредов получить выйгрыш можно.


опция raise_on_save_failure - при сохранении невалидной ассоциации add_session (или не session, а иное наименование ассоциации) будет выброшено исключение, а не nil.
так же включить FactoryBot.user_parent_strategy = true

и, да, метод add_session вызывается только от объекта, который уже есть в базе.
